# 算法

算法全部用 js 实现, 不要考虑折腾语言

## 复杂度

O(n) 表示法

- n 为操作数
- 描述的是最糟糕的情形
- 速度指操作数 n 的增速, T-n 的斜率变化

### 时间复杂度

logn
n
nlogn
n^2
n!

O 不同的时候, C 常量无关紧要, O 相同的时候, C 影响很大

### 空间复杂度

## 递归 Recursive

基线条件: base case 函数不再调用自己, 避免无限循环
递归条件: recursive case 函数调用自己

递归形成调用栈, 无需自己追踪
缺点: 函数调用栈需要内存存储函数调用信息, 如果栈很高, 会导致内存很高

- 使用循环追踪
- 尾递归(不是所有语言都支持)

## 分而治之 divide and conquer D&C

1. 找出基线条件
2. 不断将问题分解, 缩小规模, 直到符合基线条件

## 查找 Search

- 二分查找

## 排序 Sort

通用的排序算法群均需要与 O(NlogN) 进行比较

- 插入/希尔
- 冒泡
- 选择
- 快速
- 归并

## 动态规划 Dynamic Programming

动态规划的一般问题是求最值
核心问题是穷举 找出最优子结构(子问题必须独立)  
通过子问题推出更大规模的问题

解题步骤:

1. 列出状态转移方程(描述问题结构的数学形式)  dp(4) 可以根据 dp(1...3) 算出来
2. 重叠子问题(消除)
3. 使用 memo/cache 或者 dp table (自低向上) 优化 (递归 -> 非递归做法)

## 贪心算法 Greedy Algorithm

最优解

1. 选出最优解
2. 选择剩下的最优解
3. ...

每步选择局部的最优解(最优子结构), 得到的就是全局的最优解(不一定行之有效, 近似解法，因为没有考虑整体情况，未穷举一切可能)

### NP 完全问题

Non-deterministic Polynomial/多项式复杂程度的非确定性

Np 问题特点

- 时间复杂度高
- 计算所有组合才能找出最优解

#### 集合覆盖问题 Set covering problem

n 个集合
随意组合, 称为幂集(power set), 子集有 2^n 个  
穷举时间复杂度为 O(2^n)  

#### 旅行商问题

不从特定的城市出发，路线不固定

路线有 n!条数, 时间复杂度为 O(n!)

找出从每个点出发的贪婪路线进行比较

## 反向索引 Inverted Index

将正向索引反向建立 hash table, 用于 search

## 线性规划 Linear programming

最优解的一种算法
