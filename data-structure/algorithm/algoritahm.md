# 算法

## 复杂度

O(n) 表示法

- n 为操作数
- 描述的是最糟糕的情形
- 速度指操作数 n 的增速, T-n 的斜率变化

### 时间复杂度

logn
n
nlogn
n^2
n!

O 不同的时候, C 常量无关紧要, O 相同的时候, C 影响很大

### 空间复杂度

## 递归 Recursive

基线条件: base case 函数不再调用自己, 避免无限循环
递归条件: recursive case 函数调用自己

递归形成调用栈, 无需自己追踪
缺点: 函数调用栈需要内存存储函数调用信息, 如果栈很高, 会导致内存很高

- 使用循环追踪
- 尾递归(不是所有语言都支持)

## 分而治之 divide and conquer D&C

1. 找出基线条件
2. 不断将问题分解, 缩小规模, 直到符合基线条件

## 查找 Search

- 二分查找

## 动态规划 Dynamic Programming

动态规划的一般问题是求最值
核心问题是穷举 找出最优子结构(子问题必须独立)  
通过子问题推出更大规模的问题

解题步骤:

1. 列出状态转移方程(描述问题结构的数学形式)  dp(4) 可以根据 dp(1...3) 算出来
2. 重叠子问题(消除)
3. 使用 memo/cache 或者 DP table (自低向上) 优化