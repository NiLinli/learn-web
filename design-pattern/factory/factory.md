# 工厂模式

工厂: 处理创建对象的细节  
创建对象的方法称为**工厂方法**, 存在形态:

- 作为 Class 上面的方法
- 作为 Class 上面的静态方法(静态工厂方法模式)
- 直接作为函数

## 成员

- 创建者 Creator => PizzaStore
- 创建类子类 ConcreteCreator => WhPizzaStore
- 产品类 Product => Pizza
- 产品类子类 ConcreteProduct => WhCheesePizza

## 依赖倒置

依赖抽象, 不要依赖具体类

高层依赖低层组件 => 高层依赖抽象, 低层组件也依赖抽象(实现接口) , 低层组件倒置了

- 变量不可以持有具体类的引用
- 不要让类派生具体类
- 不要覆盖基类中使用的方法

## 简单工厂

不是一种模式, 适合创建类很少扩展性低的场景
工厂类中只有一个工厂方法称为简单工厂

缺点:

- 工厂类中只有一个工厂方法, 比较浪费(添加一类产品, 就要新建一个工厂类)
- 创建者依赖的时候具体的工厂类, 工厂类变化 => 创建者变化, 没有对修改关闭

## 工厂方法模式

作用于创建者, 创建者依赖单个产品, 移除工厂类

1. 创建者定义工厂抽象方法
2. 创建者子类负责实现具体的工厂方法

创建者类中的创建方法是抽象的, 对修改关闭了

## 抽象工厂模式

作用于产品, 产品依赖多个原材料(多个创建方法), 保留工厂类  
产品(此时是相对而言是创建者) 依赖于抽象工厂类, 对修改关闭

缺点: 新增产品原材料就需要改动抽象工厂接口, 影响所以的具体工厂

## 作用

创建对象封装起来, 使程序解耦, 降低对其特定实现的依赖
